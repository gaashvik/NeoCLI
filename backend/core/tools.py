import faiss
from ..models import index_metadata
from huggingface_hub import InferenceClient
import numpy as np
from ..models import session,github_toolset
from langchain_core.tools import tool
from ..utilities import interupt
from ..configuration import config
from tavily import TavilyClient
import os
from git import Repo
from typing import List




MODEL_NAME= "BAAI/bge-large-en-v1.5"
client = InferenceClient(
    provider="hf-inference",
    model=MODEL_NAME,
    token=config.HUGGING_FACE_API
)


@tool
def retrieve_context(promt:str):
    '''used to search and return contextual infromation from codebase about project. use ONLY! if users ask project related questions. else use your own knowledge'''
    db=index_metadata.MetadataDB()
    def embed(text):
        """Use HF SDK to embed text"""
        try:
            return client.feature_extraction(text, normalize=True,truncate=True)
        except Exception as e:
            print(f"HF embedding failed: {e}")
            return None
    index = faiss.read_index(f"{config.META_DIR}/.neocli/chroma/faiss.index")
    print("made it here")
    emb = embed(promt)
    print("made it here even")
    emb = np.expand_dims(emb, axis=0)

    D, I = index.search(emb, k=3)
    list=db.get_meta_for_vector_ids(I[0])
    contex=""
    for i,item in enumerate(list):
        with open (item[1],"r") as f:
            lines=f.readlines()
            contex+=(f"{i+1}. FilePath: {item[1]}\n   Start Line: {item[2]}\n   End Line: {item[3]}\n   Content:"+"".join(lines[item[2]:item[3]+1]))
        f.close()
        contex+=("\n-------------------------------------------\n")
        print("damn here as well")
    return contex

shell=session.ai_shell()
@tool
def run_shell_command(command : str) -> str:
    """Run bash shell commands. Input should be a valid shell command. and a single invocation can run a single command"""
    return shell.run(command)


gh_tool_st=github_toolset.GitHubToolset()

@tool
def generate_pr_title_and_description(source_branch:str, target_branch:str)->str:
     """Generate a PR title and description from a git diff which it find based on source and target_branch mentioned using LLM."""
     return gh_tool_st.generate_PR_title_and_desc(source_branch,target_branch)

@tool
def create_pr(source_branch:str,target_branch:str,title:str=None,description:str=None)->str:
    """
    Creates a Pull Request (PR) between two branches in the repository.

    This function assumes that the PR title and description are provided, 
    potentially generated by a separate AI/LLM tool. If not provided, 
    they can be left as None, but a separate mechanism should supply them 
    before PR creation.
    """

    return gh_tool_st.create_PR(source_branch,target_branch,title,description)


@tool
def web_search_based_on_query(query:str):
    """
    Perform a web search using Tavily based on the provided query.
    Returns relevant snippets to help answer the query. use for quick small results
    """
    tavily_client = TavilyClient(api_key="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")
    res=tavily_client.search(query)
    return res
@tool
def web_crawl_based_on_url(url:str,instruction:str):
    """
    
    Args:
        url (str): The web page URL to crawl.
        instruction (str): Instructions for summarization or extraction.
        
    Returns:
        str: The processed content returned by Tavily.
    """
    tavily_client = TavilyClient(api_key="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")
    response = tavily_client.crawl(url, instructions=instruction,limit=8)
    return response


@tool
def file_creator(relative_path: str, content: str = ""):
    """
    Create a new file at the given path with optional initial content.
    
    Args:
        relative_path (str): The relative path from the root directory.
        content (str, optional): Initial content to write to the file. Defaults to empty string.
    
    Raises:
        FileExistsError: If the file already exists.
        OSError: If the directory does not exist or file cannot be created.
    """
    # Construct full path
    path = os.path.abspath(os.path.join(config.META_DIR, relative_path))

    # Check if file already exists
    if os.path.exists(path):
        raise FileExistsError(f"File already exists: {path}")
    
    # Create parent directories if they donâ€™t exist
    os.makedirs(os.path.dirname(path), exist_ok=True)
    
    # Write content to file
    with open(path, "w", encoding="utf-8") as f:
        f.write(content)
    
    return f"File created successfully at {path}"


def update_file(relative_path: str, new_content: str, 
                mode: str = "replace", line_number: int = None):
    """
    Update a file at the given relative path based on the specified mode.
    
    Args:
        relative_path (str): The path relative to the root directory.
        new_content (str): The content to update.
        mode (str, optional): Update mode: "replace" (default), "append", or "line".
                              "replace" - replace the entire file content
                              "append" - add new content at the end
                              "line"   - replace specific line_number (requires line_number)
        line_number (int, optional): Line number to replace (1-indexed, required if mode="line")
    
    Raises:
        FileNotFoundError: If the file does not exist.
        IndexError: If the line_number is out of range when mode="line".
        ValueError: If an invalid mode is passed.
        OSError: If the file cannot be written.
    """
    path = os.path.abspath(os.path.join(config.META_DIR, relative_path))

    if not os.path.exists(path):
        raise FileNotFoundError(f"File does not exist: {path}")
    
    if mode == "replace":
        with open(path, "w", encoding="utf-8") as f:
            f.write(new_content)
    
    elif mode == "append":
        with open(path, "a", encoding="utf-8") as f:
            f.write(new_content + "\n")
    
    elif mode == "line":
        if line_number is None:
            raise ValueError("line_number must be specified when mode='line'")
        
        with open(path, "r", encoding="utf-8") as f:
            lines = f.readlines()
        
        if line_number < 1 or line_number > len(lines):
            raise IndexError(f"Line number {line_number} is out of range for {path}")
        
        lines[line_number - 1] = new_content + "\n"
        
        with open(path, "w", encoding="utf-8") as f:
            f.writelines(lines)
    
    else:
        raise ValueError(f"Invalid mode: {mode}. Choose 'replace', 'append', or 'line'.")
    
    return f"File updated successfully at {path}"

@tool
def read_file(relative_path: str) -> str:
    """
    Read the content of a file at the given relative path.
    
    Args:
        relative_path (str): Path relative to the root directory.
    
    Returns:
        str: Content of the file.
    
    Raises:
        FileNotFoundError: If the file does not exist.
        OSError: If the file cannot be read.
    """
    path = os.path.abspath(os.path.join(config.META_DIR, relative_path))
    
    if not os.path.exists(path):
        raise FileNotFoundError(f"File does not exist: {path}")
    
    with open(path, "r", encoding="utf-8") as f:
        content = f.read()
    
    return content

@tool
def git_diff(files: List[str], repo_dir: str = ".") -> str:
    """
    Generate a git diff for a list of files using GitPython. Tool is required as git dif via git command in terminal is not feasible

    Args:
        files (List[str]): List of file paths relative to the repo root.
        repo_dir (str, optional): Path to the git repository root. Defaults to current directory.

    Returns:
        str: The git diff output as a string.
    """
    if not files:
        raise ValueError("No files specified for git diff.")

    repo = Repo(os.path.join(config.GIT_STATE["repo_root"],".git"))
    if repo.bare:
        raise RuntimeError(f"Repository at {repo_dir} is bare or invalid.")

    diff_text = repo.git.diff(*files, color=False)
    return diff_text





tool_list=[interupt.add_human_in_the_loop(run_shell_command),retrieve_context,generate_pr_title_and_description,interupt.add_human_in_the_loop(create_pr),web_crawl_based_on_url,web_search_based_on_query,interupt.add_human_in_the_loop(file_creator),interupt.add_human_in_the_loop(update_file),read_file,git_diff]
error_tool_list=[retrieve_context]
if __name__ == "__main__":
    print(web_crawl_based_on_url("https://langchain-ai.github.io/langgraph/","Fetch results for how to create a agentic rag"))

